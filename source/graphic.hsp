/* 画像処理関係 */
#module Graphic
	#const TEMP_A2D_BUFFER_ID 0
	#const TEMP_OCV_BUFFER_ID 0
	#const DHASH_SIZE  2	//Difference Hashは64bit＝32bit×2(DHASH_SIZE)で表現
	#const DHASH_HEIGHT 8	//Difference HashはDHASH_WIDTH×DHASH_HEIGHTピクセル
	#const DHASH_WIDTH  9	//に縮小した後に符号化する
	#const AHASH_SIZE  2	//Average Hashは64bit＝32bit×2(AHASH_SIZE)で表現
	#const AHASH_HEIGHT 8	//Average HashはAHASH_WIDTH×AHASH_HEIGHTピクセル
	#const AHASH_WIDTH  8	//に縮小した後に符号化する
	#const OCR_HEIGHT 32	//OCR処理はOCR_WIDTH×OCR_HEIGHTピクセル
	#const OCR_WIDTH  32	//に縮小した後にマッチングさせる
	#const OCR_TEMP_ID 20
	#const OCR_MAP_ID  21
	#const OCR_TEMP_BLOCK_SIZE 36
	#const OCR_DIGITS 10
	#const OCR_A2D_MAP_ID 5
	// コンストラクタ
	#deffunc initGraphic
		//「源暎ゴシックM SemiBold」(作：おもたん氏)で出力した画像を使用
		buffer OCR_TEMP_ID, OCR_TEMP_BLOCK_SIZE * OCR_DIGITS, OCR_TEMP_BLOCK_SIZE
		picload exe_path@ + "\\template.png"
		buffer OCR_MAP_ID, (OCR_WIDTH + 2) * (OCR_DIGITS * 2 - 1), OCR_HEIGHT + 2
		for di, 0, OCR_DIGITS
			// 赤背景
			gsel OCR_MAP_ID
			color 255, 0, 0
			boxf (OCR_WIDTH + 2) * di * 2, 0, (OCR_WIDTH + 2) * (di * 2 + 1) - 1, OCR_HEIGHT + 1
			// 文字表示
			gsel OCR_TEMP_ID
			before_rect.0 = OCR_TEMP_BLOCK_SIZE * di, 0, OCR_TEMP_BLOCK_SIZE * (di + 1) - 1, OCR_TEMP_BLOCK_SIZE - 1
			dim after_rect, RECT_SIZE
			color $FF, $FF, $FF :getSquare before_rect, after_rect
			wx2 = after_rect(2) - after_rect(0) + 1
			wy2 = after_rect(3) - after_rect(1) + 1
			gsel OCR_MAP_ID
			pos (OCR_WIDTH + 2) * di * 2 + 1, 1
			gzoom OCR_WIDTH, OCR_HEIGHT, OCR_TEMP_ID, after_rect(0), after_rect(1), wx2, wy2, 1
		next
		gsel OCR_MAP_ID
		cvbuffer OCR_A2D_MAP_ID, ginfo_sx, ginfo_sy
		cvputimg OCR_A2D_MAP_ID
		;cvsave "match.png", OCR_A2D_MAP_ID
	return
	// PNG形式で保存する
	#deffunc pngsave str filename_
		// 転送前の画像についての情報を取得する
		id = ginfo_sel
		wx = ginfo_winx
		wy = ginfo_winy
		// A2Dバッファを作成し、そちらに転送する
		alCreateImage TEMP_A2D_BUFFER_ID, wx, wy
		alCopyScreenToImage id, TEMP_A2D_BUFFER_ID
		// 必要ならば、Twitter用に適宜加工する
		if(twitter_flg@Config){
			// 加工する
			clr = alGetPixel(0, 0)
			clr_r = ARGB_R(clr) :clr_g = ARGB_G(clr) :clr_b = ARGB_B(clr) :clr_a = ARGB_A(clr)
			alSetPixel 0, 0, RGBA(clr_r, clr_g, clr_b, limit(clr_a - 1, 0, 255))
			// 保存する
			alSaveFile pic_path@ + "\\ " + filename_ + "_twi.png", "image/png"
		}else{
			// 保存する
			alSaveFile pic_path@ + "\\ " + filename_+ ".png", "image/png"
		}
	return
	// 画像をカレントカラーで切り抜く
	#deffunc getSquare array input_rect_, array output_rect_
		;カレントカラーを記憶しておく
		cr = ginfo_r
		cg = ginfo_g
		cb = ginfo_b
		;検索範囲を整理する
		x_min = input_rect_(0)
		y_min = input_rect_(1)
		x_max = input_rect_(2)
		y_max = input_rect_(3)
		;検索する(上・左・下・右の順)
		for x, x_min, x_max + 1
			flg = FALSE
			for y, y_min, y_max + 1
				pget x, y
				if((ginfo_r != cr) || (ginfo_g != cg) || (ginfo_b != cb)) :flg = TRUE :_break
			next
			if(flg) :output_rect_(0) = x :_break
		next
		for y, y_min, y_max + 1
			flg = FALSE
			for x, x_min, x_max + 1
				pget x, y
				if((ginfo_r != cr) || (ginfo_g != cg) || (ginfo_b != cb)) :flg = TRUE :_break
			next
			if(flg) :output_rect_(1) = y :_break
		next
		for x, x_max, x_min - 1, -1
			flg = FALSE
			for y, y_min, y_max + 1
				pget x, y
				if((ginfo_r != cr) || (ginfo_g != cg) || (ginfo_b != cb)) :flg = TRUE :_break
			next
			if(flg) :output_rect_(2) = x :_break
		next
		for y, y_max, y_min - 1, -1
			flg = FALSE
			for x, x_min, x_max + 1
				pget x, y
				if((ginfo_r != cr) || (ginfo_g != cg) || (ginfo_b != cb)) :flg = TRUE :_break
			next
			if(flg) :output_rect_(3) = y :_break
		next
	return
	// 画像をカレントカラーで切り抜く(内部から展開する版)
	// まず、元のスクリーンに対し、次の3種が存在する。
	// ・input_rect(外枠)
	// ・output_rect(抜き出したい内枠)
	// ・cx, cy(クリック座標)
	// これに対して、内側からサーチすることで、output_rectを算出する
	// virtual_flgがTRUEだと、virtual_screen_px@GetPicとvirtual_screen_py@GetPicを
	// 考慮してズラして算出してくれる(getWindowPositionByClick用)
	#deffunc getSquareInner array input_rect_, array output_rect_, int cx_, int cy_, int virtual_flg_
		;カレントカラーを記憶しておく
		cr = ginfo_r
		cg = ginfo_g
		cb = ginfo_b
		;検索範囲を整理する
		x_min = input_rect_(0)
		y_min = input_rect_(1)
		x_max = input_rect_(2)
		y_max = input_rect_(3)
		output_rect_(0) = x_min
		output_rect_(1) = y_min
		output_rect_(2) = x_max
		output_rect_(3) = y_max
		;オフセットについて
		if(virtual_flg_){
			offset_x = -virtual_screen_px@GetPic
			offset_y = -virtual_screen_py@GetPic
		}else{
			offset_x = 0
			offset_y = 0
		}
		;検索する(上・左・下・右の順)
		for y, cy_ - 1, y_min - 1, -1
			pget cx_ + offset_x, y + offset_y
			if((ginfo_r == cr) && (ginfo_g == cg) && (ginfo_b == cb)){
				output_rect_(1) = y + 1
				_break
			}
		next
		for x, cx_ - 1, x_min - 1, -1
			pget x + offset_x, cy_ + offset_y
			if((ginfo_r == cr) && (ginfo_g == cg) && (ginfo_b == cb)){
				output_rect_(0) = x + 1
				_break
			}
		next
		for y, cy_ + 1, y_max + 1
			pget cx_ + offset_x, y + offset_y
			if((ginfo_r == cr) && (ginfo_g == cg) && (ginfo_b == cb)){
				output_rect_(3) = y - 1
				_break
			}
		next
		for x, cx_ + 1, x_max + 1
			pget x + offset_x, cy_ + offset_y
			if((ginfo_r == cr) && (ginfo_g == cg) && (ginfo_b == cb)){
				output_rect_(2) = x - 1
				_break
			}
		next
	return
	// rgbで色指定
	#deffunc color_rgb int rgb_
		color (rgb_ >> 16), (rgb_ >> 8) & $FF, rgb_ & $FF
	return
	// r,g,bをrgbに変換
	#defcfunc pack_rgb int r_, int g_, int b_
	return (r_ << 16) | (g_ << 8) | b_
	// rgbを文字に変換
	#defcfunc ToStrColor int rgb_
		rgb_r = (rgb_ >> 16)
		rgb_g = (rgb_ >> 8) & $FF
		rgb_b = rgb_ & $FF
	return strf("%d,%d,%d", rgb_r, rgb_g, rgb_b)
	// DifferenceHashを取得する
	#deffunc getDifferenceHash array dhash_, int buffer_id_, double px_, double py_, double wx_, double wy_
		// ゲーム画面の大きさから、本当のpx・py・wx・wyを取得する
		px = int(px_ * window_wx@GetPic / 100)
		py = int(py_ * window_wy@GetPic / 100)
		wx = int(wx_ * window_wx@GetPic / 100)
		wy = int(wy_ * window_wy@GetPic / 100)
		// トリミング・リサイズ処理を行う
		buffer TEMP_BUFFER_ID, DHASH_WIDTH, DHASH_HEIGHT
		gzoom DHASH_WIDTH, DHASH_HEIGHT, buffer_id_, px, py, wx, wy, 1
		// 画像をモノクロ化する
		ddim mono, DHASH_WIDTH, DHASH_HEIGHT
		for y, 0, DHASH_HEIGHT
			for x, 0, DHASH_WIDTH
				pget x, y
				mono(x, y) = 0.299 * ginfo_r + 0.587 * ginfo_g + 0.114 * ginfo_b
			next
		next
		// 隣接ピクセルとの比較結果を符号化する
		dim dhash_, DHASH_SIZE
		for k, 0, DHASH_SIZE
			for y, k * 4, (k + 1) * 4
				for x, 0, DHASH_WIDTH - 1
					dhash_(k) = dhash_(k) << 1
					if(mono(x, y) > mono(x + 1, y)) :dhash_(k) |= 1
				next
			next
		next
	return
	// DifferenceHashを取得する
	#deffunc getAverageeHash array ahash_, int buffer_id_, double px_, double py_, double wx_, double wy_
		// ゲーム画面の大きさから、本当のpx・py・wx・wyを取得する
		px = int(px_ * window_wx@GetPic / 100)
		py = int(py_ * window_wy@GetPic / 100)
		wx = int(wx_ * window_wx@GetPic / 100)
		wy = int(wy_ * window_wy@GetPic / 100)
		// トリミング・リサイズ処理を行う
		buffer TEMP_BUFFER_ID, AHASH_WIDTH, AHASH_HEIGHT
		gzoom AHASH_WIDTH, AHASH_HEIGHT, buffer_id_, px, py, wx, wy, 1
		// 画像をモノクロ化する
		ddim mono, AHASH_WIDTH, AHASH_HEIGHT
		for y, 0, AHASH_HEIGHT
			for x, 0, AHASH_WIDTH
				pget x, y
				mono(x, y) = 0.299 * ginfo_r + 0.587 * ginfo_g + 0.114 * ginfo_b
			next
		next
		// 画素値の平均値を取得する
		sum = 0.0
		for y, 0, AHASH_HEIGHT
			for x, 0, AHASH_WIDTH
				sum += mono(x, y)
			next
		next
		average_lum = sum / AHASH_WIDTH / AHASH_HEIGHT
		// 平均値より明るいか暗いかで符号化する
		dim ahash_, AHASH_SIZE
		for k, 0, AHASH_SIZE
			for y, k * 4, (k + 1) * 4
				for x, 0, AHASH_WIDTH - 1
					ahash_(k) = ahash_(k) << 1
					if(mono(x, y) > average_lum) :ahash_(k) |= 1
				next
			next
		next
	return
	// タイマーがどの数字かを判定する
	#defcfunc judgeTimerNumber array ahash_
		if(getHummingDistance(ahash_, $01e65830, $060c0c0f) < 20) :return 0	//
		if(getHummingDistance(ahash_, $03c18306, $00c1833f) < 20) :return 1	//
		if(getHummingDistance(ahash_, $03ecc081, $00618e3f) < 20) :return 2	//
		if(getHummingDistance(ahash_, $07ec408f, $01e040bf) < 20) :return 3	//
		if(getHummingDistance(ahash_, $00e3cdb3, $0c7fc183) < 20) :return 4	//
		if(getHummingDistance(ahash_, $07ec183f, $002040bf) < 20) :return 5
		if(getHummingDistance(ahash_, $c31c3827, $39343c19) < 20) :return 6
		if(getHummingDistance(ahash_, $07e04183, $00c1870e) < 20) :return 7	//
		if(getHummingDistance(ahash_, $01ccd0bb, $03c870b3) < 20) :return 8	//
		if(getHummingDistance(ahash_, $87393030, $388cf833) < 20) :return 9
	return -1
	// 数字認識用関数
	#defcfunc getNumber int buffer_id_, double px_, double py_, double wx_, double wy_, int threshold_, int nega_flg_
		// ゲーム画面の大きさから、本当のpx・py・wx・wyを取得する
		px = int(px_ * window_wx@GetPic / 100)
		py = int(py_ * window_wy@GetPic / 100)
		wx = int(wx_ * window_wx@GetPic / 100)
		wy = int(wy_ * window_wy@GetPic / 100)
		// トリミング処理を行う
		buffer TEMP_BUFFER_ID, wx, wy
		gcopy buffer_id_, px, py, wx, wy
		;bmpsave "hoge " + ei@Timer + " " + k@Graphic + "a.bmp"
		// 二値化する
		cvbuffer TEMP_OCV_BUFFER_ID, wx, wy
		cvputimg TEMP_OCV_BUFFER_ID
		cvconvert 0, TEMP_OCV_BUFFER_ID
		if(nega_flg_) :cvxors ,,, TEMP_OCV_BUFFER_ID
		;cvsave "hoge " + ei@Timer + " " + k@Graphic + "b.bmp", TEMP_OCV_BUFFER_ID
		if(threshold_ >= 0){
			cvthreshold CV_THRESH_BINARY, threshold_, 255, TEMP_OCV_BUFFER_ID
		}else{
			cvthreshold CV_THRESH_OTSU, threshold_, 255, TEMP_OCV_BUFFER_ID
		}
		// クロップした上で、マッチングのためOCR_WIDTH×OCR_HEIGHTピクセルに変形
		cvgetimg TEMP_OCV_BUFFER_ID
		before_rect.0 = 0, 0, wx - 1, wy - 1
		dim after_rect, RECT_SIZE
		color $FF, $FF, $FF :getSquare before_rect, after_rect
		wx2 = after_rect(2) - after_rect(0) + 1
		wy2 = after_rect(3) - after_rect(1) + 1
		buffer TEMP_BUFFER_ID2, OCR_WIDTH + 2, OCR_HEIGHT + 2
		color 255, 0, 0 :boxf :pos 1,1 :gzoom OCR_WIDTH, OCR_HEIGHT, TEMP_BUFFER_ID, after_rect(0), after_rect(1), wx2, wy2, 1
		;bmpsave "hoge " + ei@Timer + " " + k@Graphic + "c.bmp"
		// マッチング処理
		cvbuffer TEMP_OCV_BUFFER_ID, OCR_WIDTH + 2, OCR_HEIGHT + 2
		cvputimg TEMP_OCV_BUFFER_ID
		cvmatch match_x, match_y, CV_TM_SQDIFF, TEMP_OCV_BUFFER_ID, OCR_A2D_MAP_ID
	return limit(int(1.0 * match_x / (OCR_WIDTH + 2) / 2 + 0.5), 0, 9)
	// ある長さの数字列を認識する
	#deffunc getTimerOCR array timer_digit_, int buffer_id_, array px_arr_, double py_, double wx_, double wy_, int threshold_, int nega_flg_
		for k, 0, length(timer_digit_)
			timer_digit_(k) = getNumber(buffer_id_, px_arr_(k), py_, wx_, wy_, threshold_, nega_flg_)
		next
	return
#global
