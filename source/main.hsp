#define global SOFT_NAME "WGH"
#packopt name SOFT_NAME

#include "a2d.hsp"

#const global TRUE  1
#const global FALSE 0

#module Utility
	// 現在時刻を文字列形式で返す
	#defcfunc getNowTimeStr
		yy = gettime(0)
		mo = gettime(1)
		dd = gettime(3)
		hh = gettime(4)
		mi = gettime(5)
		ss = gettime(6)
		ms = gettime(7)
	return strf("%04d-%02d-%02d %02d-%02d-%02d-%03d", yy, mo, dd, hh, mi, ss, ms)
#global

#module Config
	// 設定を読み込んで初期化する
	#deffunc initConfig
		twitter_flg = FALSE	//Twitter投稿用にスクショを加工するならTRUE
		getpos_flg = FALSE	//座標を取得できていればTRUE
	return
#global

#module Graphic
	#const TEMP_A2D_BUFFER_ID 0
	// PNG形式で保存する
	#deffunc pngsave str filename_
		// 転送前の画像についての情報を取得する
		id = ginfo_sel
		wx = ginfo_winx
		wy = ginfo_winy
		// A2Dバッファを作成し、そちらに転送する
		alCreateImage TEMP_A2D_BUFFER_ID, wx, wy
		alCopyScreenToImage id, TEMP_A2D_BUFFER_ID
		// 必要ならば、Twitter用に適宜加工する
		if(twitter_flg@Config){
			// 加工する
			clr = alGetPixel(0, 0)
			clr_r = ARGB_R(clr) :clr_g = ARGB_G(clr) :clr_b = ARGB_B(clr) :clr_a = ARGB_A(clr)
			alSetPixel 0, 0, RGBA(clr_r, clr_g, clr_b, limit(clr_a - 1, 0, 255))
			// 保存する
			alSaveFile filename_ + "_twi.png", "image/png"
		}else{
			// 保存する
			alSaveFile filename_+ ".png", "image/png"
		}
	return
	// 画像をカレントカラーで切り抜く
	#deffunc getSquare array input_rect, array output_rect
		;カレントカラーを記憶しておく
		cr = ginfo_r
		cg = ginfo_g
		cb = ginfo_b
		;検索範囲を整理する
		x_min = input_rect(0)
		y_min = input_rect(1)
		x_max = input_rect(2)
		y_max = input_rect(3)
		;検索する(上・左・下・右の順)
		for x, x_min, x_max
			flg = FALSE
			for y, y_min, y_max
				pget x, y
				if((ginfo_r != rr) || (ginfo_g != gg) || (ginfo_b != bb)) :flg = TRUE :_break
			next
			if(flg) :output_rect(0) = x :_break
		next
		for y, y_min, y_max
			flg = FALSE
			for x, x_min, x_max
				pget x, y
				if((ginfo_r != rr) || (ginfo_g != gg) || (ginfo_b != bb)) :flg = TRUE :_break
			next
			if(flg) :output_rect(1) = y :_break
		next
		for x, x_max - 1, x_min - 1, -1
			flg = FALSE
			for y, y_min, y_max
				pget x, y
				if((ginfo_r != rr) || (ginfo_g != gg) || (ginfo_b != bb)) :flg = TRUE :_break
			next
			if(flg) :output_rect(2) = x :_break
		next
		for y, y_max - 1, y_min - 1, -1
			flg = FALSE
			for x, x_min, x_max
				pget x, y
				if((ginfo_r != rr) || (ginfo_g != gg) || (ginfo_b != bb)) :flg = TRUE :_break
			next
			if(flg) :output_rect(3) = y :_break
		next
	return
#global

#module GetPic
	#uselib "gdi32.dll"
		#func  BitBlt "BitBlt" int,int,int,int,int,int,int,int,int
		#cfunc CreateDC "CreateDCA" sptr,sptr,sptr,int
		#func  DeleteDC "DeleteDC" int
	#uselib "user32.dll"
		#cfunc GetSystemMetrics "GetSystemMetrics" int
		#cfunc WindowFromPoint "WindowFromPoint" int, int
		#func  GetWindowRect "GetWindowRect" int, int
	// API関係の定数
	#const NULL 0
	#const SRCCOPY    0x00CC0020
	#const CAPTUREBLT 0x40000000
	#const SM_XVIRTUALSCREEN  0x0000004C
	#const SM_YVIRTUALSCREEN  0x0000004D
	#const SM_CXVIRTUALSCREEN 0x0000004E
	#const SM_CYVIRTUALSCREEN 0x0000004F
	// API関係ではない定数
	#const RECT_SIZE 4
	#const VIRTUAL_SCREEN_ID 10
	#const CLICK_SCREEN_ID   11
	#const TEMP_BUFFER_ID    12
	// GetPicモジュールを初期化
	#deffunc initGetPic
		// 仮想画面の左上座標および大きさを取得
		virtual_screen_px = GetSystemMetrics(SM_XVIRTUALSCREEN)
		virtual_screen_py = GetSystemMetrics(SM_YVIRTUALSCREEN)
		virtual_screen_wx = GetSystemMetrics(SM_CXVIRTUALSCREEN)
		virtual_screen_wy = GetSystemMetrics(SM_CYVIRTUALSCREEN)
	return
	// クリックした画面を捕捉する
	#defcfunc getWindowPositionByClick
		// 仮想画面全体をスクショして、縁無しウィンドウ表示する
		buffer VIRTUAL_SCREEN_ID, virtual_screen_wx, virtual_screen_wy
		hdc_screen = CreateDC("DISPLAY", NULL, NULL, NULL)
		BitBlt hdc, 0, 0, virtual_screen_wx, virtual_screen_wy, hdc_screen, virtual_screen_px, virtual_screen_py, SRCCOPY | CAPTUREBLT
		DeleteDC hdc_screen
		bgscr CLICK_SCREEN_ID, virtual_screen_wx, virtual_screen_wy,,virtual_screen_px, virtual_screen_py
		gcopy VIRTUAL_SCREEN_ID, 0, 0, virtual_screen_wx, virtual_screen_wy
		// 戦艦少女のウィンドウをクリックさせる
		;dialog "戦艦少女の画面をクリックしてください.", 0, SOFT_NAME
		click_flg = FALSE
		repeat
			stick key
			if(key & 256){
				window_position_x = mousex + virtual_screen_px
				window_position_y = mousey + virtual_screen_py
				click_flg = TRUE
				break
			}
			if(key & 128){
				break
			}
			wait 5
		loop
		gsel CLICK_SCREEN_ID, -1
		if(click_flg == FALSE) :return FALSE
		// クリック位置から対象のウィンドウのハンドル・位置・サイズを取得する
		window_handle = WindowFromPoint(window_position_x, window_position_y)
		dim rect, RECT_SIZE
		GetWindowRect window_handle, varptr(rect)
		// 周囲の黒枠を削除する処理
		dim crop_rect, 4
		color :getSquare rect, crop_rect
		window_px = crop_rect(0)
		window_py = crop_rect(1)
		window_wx = crop_rect(2) - crop_rect(0) + 1
		window_wy = crop_rect(3) - crop_rect(1) + 1
		// フラグ処理
		getpos_flg@Config = TRUE
	return TRUE
	// 捕捉した画面を保存する
	#deffunc saveWindowImage
		// 座標が取得できていなければ保存を行わない
		if(getpos_flg@Config == FALSE) :return
		// 画像をBitBltで取得する
		buffer TEMP_BUFFER_ID, window_wx, window_wy
		hdc_screen = CreateDC("DISPLAY", NULL, NULL, NULL)
		BitBlt hdc, 0, 0, window_wx, window_wy, hdc_screen, window_px, window_py, SRCCOPY | CAPTUREBLT
		DeleteDC hdc_screen
		// 取得した画像を保存する
		pngsave getNowTimeStr()
	return
#global

#module GUI
	#const MAIN_WINDOW_ID 0
	#const BUTTON_X  64
	#const BUTTON_Y  24
	#const OBJ_SPACE 10
	#deffunc initGUI
		screen MAIN_WINDOW_ID, 200, OBJ_SPACE * 3 + BUTTON_Y * 2
		gsel MAIN_WINDOW_ID, 2
		title SOFT_NAME
		pos 10, 10 :objsize 180, 24 :button gosub "座標取得", *getWPBC :button_getwpbc_id = stat
		pos 10, 44 :objsize 64, 24 :button gosub "画像保存", *savePicture
		pos 84, 44 :objsize 80, 24 :chkbox "for Twitter", twitter_flg@Config
	return
*getWPBC
	if(getWindowPositionByClick()){
		gsel MAIN_WINDOW_ID
		objprm button_getwpbc_id, "(" + window_px@GetPic + "," + window_py@GetPic + ") " + window_wx@GetPic + "x" + window_wy@GetPic
	}
	return
*savePicture
	saveWindowImage
	return
#global

initConfig
initGetPic
initGUI
stop
